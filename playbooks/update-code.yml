---
# Update XAI code on nodes with rolling deployment
# Features: Serial execution, pre/post health checks, sync verification, rollback on failure
#
# SINGLE SOURCE OF TRUTH: This playbook is the authoritative deployment logic for XAI.
# CI/CD workflows MUST use this playbook - never duplicate deployment logic elsewhere.
#
# Usage:
#   Manual (git):    ansible-playbook -i inventory/testnet.yml playbooks/update-code.yml
#   CI/CD (tarball): ansible-playbook -i inventory/testnet.yml playbooks/update-code.yml \
#                      -e "deploy_package=/path/to/xai-source.tar.gz" \
#                      -e "deploy_version=abc123"
#   Single node:     ansible-playbook -i inventory/testnet.yml playbooks/update-code.yml --limit xai_val1
#   Skip backup:     ansible-playbook -i inventory/testnet.yml playbooks/update-code.yml -e skip_backup=true
#
# Deployment Modes:
#   - If deploy_package is defined: Extract from tarball (CI/CD mode)
#   - If deploy_package is undefined: Pull from git repository (manual mode)

- name: Update XAI code with rolling deployment
  hosts: nodes
  become: yes
  serial: 1  # Deploy one node at a time for zero-downtime rolling updates
  gather_facts: yes
  max_fail_percentage: 0  # Fail entire play if any node fails

  vars:
    # Health check configuration
    health_check_retries: 30
    health_check_delay: 10  # seconds (30 * 10 = 5 minutes total)
    sync_tolerance_blocks: 5  # How far behind network is acceptable

    # Backup configuration
    backup_dir: "/home/{{ daemon_user }}/xai-backups"
    skip_backup: false

    # Service name pattern (matches systemd units)
    service_name: "xai-mvp-{{ node_name }}"

    # Deployment mode detection
    # CI/CD sets deploy_package; manual runs use git
    use_tarball_deploy: "{{ deploy_package is defined and deploy_package | length > 0 }}"

    # Git configuration (for manual deployments)
    git_repo: "https://github.com/xai-blockchain/xai.git"
    git_branch: "main"

  handlers:
    - name: rollback deployment
      ansible.builtin.include_tasks: rollback.yml

  pre_tasks:
    - name: Display deployment info
      ansible.builtin.debug:
        msg: |
          Starting rolling update for {{ node_name }}
          Server: {{ ansible_host }}
          RPC Port: {{ rpc_port }}
          Service: {{ service_name }}
          Deployment mode: {{ 'CI/CD (tarball)' if (use_tarball_deploy | bool) else 'Manual (git)' }}
          {% if use_tarball_deploy | bool %}Version: {{ deploy_version | default('unknown') }}{% else %}Branch: {{ git_branch }}{% endif %}

  tasks:
    # ============================================================
    # PHASE 1: Pre-deployment health check
    # ============================================================
    - name: "Pre-check: Verify node is currently healthy"
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ rpc_port }}/stats"
        return_content: yes
        timeout: 30
      register: pre_health
      failed_when: false

    - name: "Pre-check: Record initial state"
      ansible.builtin.set_fact:
        initial_height: "{{ pre_health.json.chain_height | default(0) }}"
        initial_peers: "{{ pre_health.json.peer_count | default(0) }}"
        node_was_healthy: "{{ pre_health.status | default(0) == 200 }}"

    - name: "Pre-check: Display initial state"
      ansible.builtin.debug:
        msg: |
          Initial state for {{ node_name }}:
          - Status: {{ 'Healthy' if node_was_healthy else 'Unhealthy/Offline' }}
          - Height: {{ initial_height }}
          - Peers: {{ initial_peers }}

    - name: "Pre-check: Warn if node was unhealthy"
      ansible.builtin.debug:
        msg: "WARNING: Node {{ node_name }} was not healthy before update. Proceeding anyway."
      when: not node_was_healthy

    # ============================================================
    # PHASE 2: Create backup
    # ============================================================
    - name: Create backup directory
      ansible.builtin.file:
        path: "{{ backup_dir }}"
        state: directory
        owner: "{{ daemon_user }}"
        mode: '0755'
      when: not skip_backup

    - name: Backup current code
      ansible.builtin.shell: |
        # Remove old latest backup
        rm -rf {{ backup_dir }}/{{ node_name }}-latest
        # Create timestamped backup
        timestamp=$(date +%Y%m%d_%H%M%S)
        cp -a {{ xai_home }} {{ backup_dir }}/{{ node_name }}-${timestamp}
        # Create symlink to latest
        ln -sfn {{ backup_dir }}/{{ node_name }}-${timestamp} {{ backup_dir }}/{{ node_name }}-latest
        echo "Backup created: {{ node_name }}-${timestamp}"
      become_user: "{{ daemon_user }}"
      register: backup_result
      when: not skip_backup

    - name: Display backup status
      ansible.builtin.debug:
        msg: "{{ backup_result.stdout }}"
      when: not skip_backup and backup_result.stdout is defined

    # ============================================================
    # PHASE 3: Stop node service
    # ============================================================
    - name: Stop node service
      ansible.builtin.service:
        name: "{{ service_name }}"
        state: stopped
      register: stop_result

    - name: Wait for service to fully stop
      ansible.builtin.wait_for:
        port: "{{ rpc_port }}"
        state: stopped
        timeout: 60
      ignore_errors: yes  # Port may already be closed

    - name: Verify service is stopped
      ansible.builtin.shell: |
        systemctl is-active {{ service_name }} || true
      register: service_state
      changed_when: false

    - name: Confirm service stopped
      ansible.builtin.assert:
        that:
          - service_state.stdout == 'inactive' or service_state.stdout == 'failed'
        fail_msg: "Service {{ service_name }} failed to stop cleanly"
        success_msg: "Service {{ service_name }} stopped successfully"

    # ============================================================
    # PHASE 4: Deploy new code
    # ============================================================

    # --- CI/CD MODE: Deploy from tarball ---
    - name: "Deploy (tarball): Display deployment mode"
      ansible.builtin.debug:
        msg: |
          DEPLOYMENT MODE: Tarball (CI/CD)
          Package: {{ deploy_package }}
          Version: {{ deploy_version | default('unknown') }}
      when: use_tarball_deploy | bool

    - name: "Deploy (tarball): Copy package to server"
      ansible.builtin.copy:
        src: "{{ deploy_package }}"
        dest: "/tmp/xai-deploy-package.tar.gz"
        mode: '0644'
      when: use_tarball_deploy | bool
      notify: "rollback deployment"

    - name: "Deploy (tarball): Clear existing code directory"
      ansible.builtin.file:
        path: "{{ xai_home }}/src"
        state: absent
      become_user: "{{ daemon_user }}"
      when: use_tarball_deploy | bool

    - name: "Deploy (tarball): Ensure xai_home exists"
      ansible.builtin.file:
        path: "{{ xai_home }}"
        state: directory
        owner: "{{ daemon_user }}"
        mode: '0755'
      when: use_tarball_deploy | bool

    - name: "Deploy (tarball): Extract package"
      ansible.builtin.unarchive:
        src: "/tmp/xai-deploy-package.tar.gz"
        dest: "{{ xai_home }}"
        remote_src: yes
        owner: "{{ daemon_user }}"
        group: "{{ daemon_user }}"
      become_user: "{{ daemon_user }}"
      when: use_tarball_deploy | bool
      register: tarball_result
      notify: "rollback deployment"

    - name: "Deploy (tarball): Clean up temporary package"
      ansible.builtin.file:
        path: "/tmp/xai-deploy-package.tar.gz"
        state: absent
      when: use_tarball_deploy | bool

    - name: "Deploy (tarball): Record deployment info"
      ansible.builtin.set_fact:
        git_result:
          before: "tarball-deploy"
          after: "{{ deploy_version | default('unknown') }}"
          changed: true
      when: use_tarball_deploy | bool

    # --- MANUAL MODE: Deploy from git ---
    - name: "Deploy (git): Display deployment mode"
      ansible.builtin.debug:
        msg: |
          DEPLOYMENT MODE: Git (manual)
          Repository: {{ git_repo }}
          Branch: {{ git_branch }}
      when: not (use_tarball_deploy | bool)

    - name: "Deploy (git): Pull latest code from repository"
      ansible.builtin.git:
        repo: "{{ git_repo }}"
        dest: "{{ xai_home }}"
        version: "{{ git_branch }}"
        force: yes
      become_user: "{{ daemon_user }}"
      register: git_result
      when: not (use_tarball_deploy | bool)
      notify: "rollback deployment"

    # --- Common: Display update info ---
    - name: Display code update info
      ansible.builtin.debug:
        msg: |
          Code update result:
          - Before: {{ git_result.before | default('N/A') }}
          - After: {{ git_result.after | default('N/A') }}
          - Changed: {{ git_result.changed }}

    - name: Install/update Python dependencies
      ansible.builtin.pip:
        requirements: "{{ xai_home }}/requirements.txt"
        virtualenv: "{{ venv_path }}"
        state: latest
      become_user: "{{ daemon_user }}"
      notify: "rollback deployment"

    # ============================================================
    # PHASE 5: Start node service
    # ============================================================
    - name: Start node service
      ansible.builtin.service:
        name: "{{ service_name }}"
        state: started
      register: start_result
      notify: "rollback deployment"

    - name: Wait for RPC port to be available
      ansible.builtin.wait_for:
        port: "{{ rpc_port }}"
        state: started
        timeout: 120
      notify: "rollback deployment"

    # ============================================================
    # PHASE 6: Post-deployment health check - basic connectivity
    # ============================================================
    - name: "Post-check: Wait for node to respond"
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ rpc_port }}/stats"
        return_content: yes
        timeout: 30
      register: post_health
      until: post_health.status == 200 and post_health.json.chain_height is defined
      retries: "{{ health_check_retries }}"
      delay: "{{ health_check_delay }}"
      notify: "rollback deployment"

    - name: "Post-check: Record post-deployment state"
      ansible.builtin.set_fact:
        current_height: "{{ post_health.json.chain_height }}"
        current_peers: "{{ post_health.json.peer_count | default(0) }}"
        is_mining: "{{ post_health.json.mining | default(false) }}"

    - name: "Post-check: Display post-deployment state"
      ansible.builtin.debug:
        msg: |
          Post-deployment state for {{ node_name }}:
          - Height: {{ current_height }}
          - Peers: {{ current_peers }}
          - Mining: {{ is_mining }}

    # ============================================================
    # PHASE 7: Sync verification - ensure node catches up
    # ============================================================
    - name: "Sync check: Get network height from sentry1"
      ansible.builtin.uri:
        url: "http://{{ hostvars['xai_sentry1'].ansible_host }}:{{ hostvars['xai_sentry1'].rpc_port }}/stats"
        return_content: yes
        timeout: 30
      register: network_status
      failed_when: false
      delegate_to: "{{ groups['primary_sentries'][0] }}"
      run_once: false
      when: inventory_hostname != 'xai_sentry1'

    - name: "Sync check: Use current node height if reference unavailable"
      ansible.builtin.set_fact:
        network_height: "{{ network_status.json.chain_height | default(current_height) }}"
      when: network_status is defined

    - name: "Sync check: Verify node is syncing"
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ rpc_port }}/stats"
        return_content: yes
      register: sync_check
      until: >
        (sync_check.json.chain_height | int) >= ((network_height | default(current_height) | int) - sync_tolerance_blocks)
      retries: "{{ health_check_retries }}"
      delay: "{{ health_check_delay }}"
      notify: "rollback deployment"

    - name: "Sync check: Final height verification"
      ansible.builtin.set_fact:
        final_height: "{{ sync_check.json.chain_height }}"

    # ============================================================
    # PHASE 8: Final validation
    # ============================================================
    - name: "Validation: Check node is progressing"
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ rpc_port }}/stats"
        return_content: yes
      register: progress_check_1

    - name: "Validation: Wait and check again"
      ansible.builtin.pause:
        seconds: 15

    - name: "Validation: Verify height increased"
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ rpc_port }}/stats"
        return_content: yes
      register: progress_check_2

    - name: "Validation: Confirm chain is progressing"
      ansible.builtin.assert:
        that:
          - progress_check_2.json.chain_height | int >= progress_check_1.json.chain_height | int
        fail_msg: |
          Node {{ node_name }} is not progressing!
          Height before: {{ progress_check_1.json.chain_height }}
          Height after: {{ progress_check_2.json.chain_height }}
        success_msg: "Node {{ node_name }} is healthy and progressing"
      notify: "rollback deployment"

    # ============================================================
    # PHASE 9: Success summary
    # ============================================================
    - name: "Success: Display update summary"
      ansible.builtin.debug:
        msg: |
          ====================================================
          SUCCESS: {{ node_name }} updated successfully!
          ====================================================
          Deployment mode: {{ 'CI/CD (tarball)' if (use_tarball_deploy | bool) else 'Manual (git)' }}
          Version/Commit: {{ git_result.after | default('N/A') }}
          Initial height: {{ initial_height }}
          Final height: {{ final_height }}
          Height change: +{{ (final_height | int) - (initial_height | int) }}
          Peers: {{ progress_check_2.json.peer_count | default('N/A') }}
          Mining: {{ progress_check_2.json.mining | default('N/A') }}
          ====================================================
          Proceeding to next node...
          ====================================================

  post_tasks:
    - name: Clean up old backups (keep last 3)
      ansible.builtin.shell: |
        cd {{ backup_dir }} 2>/dev/null || exit 0
        ls -dt {{ node_name }}-20* 2>/dev/null | tail -n +4 | xargs rm -rf 2>/dev/null || true
      become_user: "{{ daemon_user }}"
      when: not skip_backup
      changed_when: false
